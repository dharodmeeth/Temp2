USE [ADMINDBA]
GO

/****** Object:  StoredProcedure [dbo].[ETL_ClientUpdate]    Script Date: 10/1/2025 2:29:43 AM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO


ALTER   PROCEDURE [dbo].[ETL_ClientUpdate]
AS
BEGIN
    SET NOCOUNT ON;

    ----------------------------------------------------------------------------------
    -- Step 0: Ensure logging table exists
    ----------------------------------------------------------------------------------
    IF OBJECT_ID('dbo.ETLFailedLog', 'U') IS NULL
    BEGIN
        CREATE TABLE dbo.ETLFailedLog (
            LogID INT IDENTITY(1,1) PRIMARY KEY,
            ClientCode NVARCHAR(50),
            DatabaseName SYSNAME,
            JobName NVARCHAR(128),
            ServerName NVARCHAR(128),
            Message NVARCHAR(MAX),
            Status NVARCHAR(20),
            StatusType NVARCHAR(50),
            EventDate DATETIME DEFAULT GETDATE(),
            RunID UNIQUEIDENTIFIER,
            LoggedOn DATETIME DEFAULT GETDATE()
        );
    END

    ----------------------------------------------------------------------------------
    -- Declare @ReturnMessage once for dynamic SQL
    ----------------------------------------------------------------------------------
    DECLARE @ReturnMessage NVARCHAR(MAX) = NULL;

    ----------------------------------------------------------------------------------
    -- Step 1: Clear ETLClientInfo columns
    ----------------------------------------------------------------------------------
    UPDATE C
    SET 
        C.Message = NULL,
        C.EventDate = NULL,
        C.Status = NULL,
        C.JobName = NULL
    FROM dbo.ETLClientInfo C;

    ----------------------------------------------------------------------------------
    -- Step 2: Update ETLClientInfo with last SQL Agent run per job
    ----------------------------------------------------------------------------------
    UPDATE C
    SET 
        C.JobName   = SJ.name,
        C.Message   = SJH.message,
        C.EventDate = DATEADD(S, 
                        (SJH.run_time / 10000) * 60 * 60 + 
                        ((SJH.run_time - (SJH.run_time / 10000) * 10000) / 100) * 60 + 
                        (SJH.run_time - (SJH.run_time / 100) * 100), 
                        CONVERT(DATETIME, RTRIM(SJH.run_date), 113)),
        C.Status    = CASE 
                        WHEN SJH.run_status = 0 THEN 'Failed'
                        WHEN SJH.run_status = 1 THEN 'Succeeded'
                        WHEN SJH.run_status = 2 THEN 'Retry'
                        WHEN SJH.run_status = 3 THEN 'Cancelled'
                        ELSE 'Unknown'
                      END
    FROM dbo.ETLClientInfo C
    JOIN msdb..sysjobs SJ
        ON SJ.name LIKE '%' + C.ClientCode + '%'
    CROSS APPLY (
        SELECT TOP 1 *
        FROM msdb..sysjobhistory H
        WHERE H.job_id = SJ.job_id
          AND H.step_id = 0
        ORDER BY H.run_date DESC, H.run_time DESC
    ) SJH
    WHERE SJ.name LIKE 'DXRA%'
      AND C.IsActive = 1;

    ----------------------------------------------------------------------------------
    -- Step 3: Baseline logging of all active clients
    ----------------------------------------------------------------------------------
    DECLARE @RunID UNIQUEIDENTIFIER = NEWID();

    INSERT INTO dbo.ETLFailedLog (ClientCode, DatabaseName, JobName, ServerName, Message, Status, StatusType, EventDate, RunID)
    SELECT 
        C.ClientCode, 
        C.DatabaseName, 
        C.JobName, 
        C.ServerName, 
        C.Message,
        ISNULL(C.Status, 'Null') AS Status,
        'Baseline' AS StatusType,
        ISNULL(C.EventDate, GETDATE()),
        @RunID
    FROM dbo.ETLClientInfo C
    WHERE C.IsActive = 1;

    ----------------------------------------------------------------------------------
    -- Step 4a: One-time database initialization per database
    ----------------------------------------------------------------------------------
    DECLARE @InitSQL NVARCHAR(MAX) = N'';

    SELECT @InitSQL = STRING_AGG(
    N'BEGIN TRY
        USE ' + QUOTENAME(X.DatabaseName) + N';
        IF EXISTS (SELECT * FROM sys.symmetric_keys WHERE name = ''FTPPSWDKey'')
            DROP SYMMETRIC KEY FTPPSWDKey;
        IF EXISTS (SELECT * FROM sys.certificates WHERE name = ''CertificateETLFTP'')
            DROP CERTIFICATE CertificateETLFTP;
        IF EXISTS (SELECT * FROM sys.symmetric_keys WHERE name = ''##MS_DatabaseMasterKey##'')
            DROP MASTER KEY;
        EXEC [dbo].[BI_spCreateCertificateKey] @ReturnMessage OUTPUT;
    END TRY
    BEGIN CATCH
        -- Errors already logged in Step 3
    END CATCH'
    , CHAR(13)+CHAR(10))
    FROM (SELECT DISTINCT C.DatabaseName FROM dbo.ETLClientInfo C WHERE C.IsActive = 1) X;

    IF @InitSQL IS NOT NULL
        EXEC sp_executesql @InitSQL, N'@ReturnMessage NVARCHAR(MAX) OUTPUT', @ReturnMessage=@ReturnMessage OUTPUT;

    ----------------------------------------------------------------------------------
    -- Step 4b: Per client execution using cursor (failed/null clients)
    ----------------------------------------------------------------------------------
    DECLARE @ClientCode NVARCHAR(50),
            @DatabaseName SYSNAME,
            @JobName NVARCHAR(128),
            @Pwd NVARCHAR(MAX),
            @SQL NVARCHAR(MAX);

    DECLARE ClientCursor CURSOR FOR
    SELECT 
        C.ClientCode, 
        C.DatabaseName, 
        C.JobName, 
        ISNULL(C.Pwd,'') AS Pwd
    FROM dbo.ETLClientInfo C
    JOIN dbo.ETLFailedLog L
      ON C.ClientCode = L.ClientCode
     AND C.DatabaseName = L.DatabaseName
     AND L.RunID = @RunID
    WHERE L.Status <> 'Succeeded'
      AND C.IsActive = 1;

    OPEN ClientCursor;
    FETCH NEXT FROM ClientCursor INTO @ClientCode, @DatabaseName, @JobName, @Pwd;

    WHILE @@FETCH_STATUS = 0
    BEGIN
        SET @SQL = '
        BEGIN TRY
            USE ' + QUOTENAME(@DatabaseName) + ';
            EXEC [dbo].[BI_spCreateCertificateKey] @ReturnMessage OUTPUT;

            EXEC [dbo].[BI_spETLConfigurationInsert]
                @clientid = ''' + @ClientCode + ''',
                @FtpPassword = ''' + @Pwd + ''';

            USE msdb;
            EXEC msdb.dbo.sp_start_job @job_name = ''' + @JobName + ''';
        END TRY
        BEGIN CATCH
            -- Errors already logged in Step 3
        END CATCH';

        EXEC sp_executesql @SQL, N'@ReturnMessage NVARCHAR(MAX) OUTPUT', @ReturnMessage=@ReturnMessage OUTPUT;

        FETCH NEXT FROM ClientCursor INTO @ClientCode, @DatabaseName, @JobName, @Pwd;
    END

    CLOSE ClientCursor;
    DEALLOCATE ClientCursor;

    ----------------------------------------------------------------------------------
    -- Step 5: Send email only for failed/null clients
    ----------------------------------------------------------------------------------
    IF EXISTS (SELECT 1 FROM dbo.ETLFailedLog L WHERE L.RunID = @RunID AND L.Status <> 'Succeeded')
    BEGIN
        DECLARE @body NVARCHAR(MAX);
        DECLARE @ServerNames NVARCHAR(MAX);
        DECLARE @subject NVARCHAR(512);

        SELECT @ServerNames = STRING_AGG(L.ServerName, ', ')
        FROM (SELECT DISTINCT L.ServerName FROM dbo.ETLFailedLog L WHERE L.RunID = @RunID AND L.Status <> 'Succeeded') AS L;

        SET @body = 
        N'<h3>ETL Execution Report - Failed Clients</h3>' +
        N'<table border="1" cellpadding="5" cellspacing="0" style="border-collapse:collapse;">' +
        N'<tr style="background-color:lightblue;">
<th>ClientCode</th><th>ServerName</th><th>DatabaseName</th>
<th>JobName</th><th>Message</th><th>Status</th><th>EventDate</th></tr>' +
        (
            SELECT STRING_AGG(
                N'<tr><td>' + ISNULL(L.ClientCode, '') + N'</td>' +
                N'<td>' + ISNULL(L.ServerName, '') + N'</td>' +
                N'<td>' + ISNULL(L.DatabaseName, '') + N'</td>' +
                N'<td>' + ISNULL(L.JobName, '') + N'</td>' +
                N'<td>' + ISNULL(L.Message, '') + N'</td>' +
                N'<td>' + ISNULL(L.Status, '') + N'</td>' +
                N'<td>' + ISNULL(CONVERT(VARCHAR(20), L.EventDate, 120), '') + N'</td></tr>'
            , CHAR(13)+CHAR(10))
            FROM dbo.ETLFailedLog L
            WHERE L.RunID = @RunID AND L.Status <> 'Succeeded'
        );

        SET @body = @body + N'</table>';
        SET @subject = N'ETL Execution Report - Failed Clients Only'
                       + CASE WHEN @ServerNames IS NOT NULL THEN N' | Servers: ' + @ServerNames ELSE N'' END;

        EXEC msdb.dbo.sp_send_dbmail
            @profile_name = 'DBA',
            @recipients   = 'luiza.vladescu@Fisglobal.com;meeth.dharod@Fisglobal.com;shivam.gupta3@fisglobal.com',
            @subject      = @subject,
            @body         = @body,
            @body_format  = 'HTML';
    END

    ----------------------------------------------------------------------------------
    -- Step 6: Cleanup old log data (>10 days)
    ----------------------------------------------------------------------------------
    DELETE FROM dbo.ETLFailedLog
    WHERE LoggedOn < DATEADD(DAY, -10, GETDATE());

END
GO

Msg 9829, Level 16, State 1, Procedure dbo.ETL_ClientUpdate, Line 100 [Batch Start Line 14]
STRING_AGG aggregation result exceeded the limit of 8000 bytes. Use LOB types to avoid result truncation.


